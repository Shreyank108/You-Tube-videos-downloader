'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchAndSave = exports.saveMedia = exports.saveJson = undefined;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _each = require('lodash/each');

var _each2 = _interopRequireDefault(_each);

var _partial = require('lodash/partial');

var _partial2 = _interopRequireDefault(_partial);

var _some = require('lodash/some');

var _some2 = _interopRequireDefault(_some);

var _reject = require('lodash/reject');

var _reject2 = _interopRequireDefault(_reject);

var _assign = require('lodash/assign');

var _assign2 = _interopRequireDefault(_assign);

var _once = require('lodash/once');

var _once2 = _interopRequireDefault(_once);

var _async = require('async');

var _request = require('request');

var _request2 = _interopRequireDefault(_request);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _debug = require('./debug');

var _debug2 = _interopRequireDefault(_debug);

var _urlToPath2 = require('./urlToPath');

var _urlToPath3 = _interopRequireDefault(_urlToPath2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debugApi = (0, _debug2.default)('api');
var debugJson = (0, _debug2.default)('json');
var debugMedia = (0, _debug2.default)('media');

var stripUrlParts = function stripUrlParts(url) {
  for (var _len = arguments.length, rejects = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rejects[_key - 1] = arguments[_key];
  }

  var rejector = function rejector(part) {
    return (0, _some2.default)(rejects, function (r) {
      return part.match(r);
    });
  };
  var parsed = _url2.default.parse(url);
  var newUrl = _url2.default.format((0, _assign2.default)(parsed, {
    pathname: (0, _reject2.default)(parsed.pathname.split('/'), rejector).join('/')
  }));
  return url !== newUrl ? newUrl : null;
};

var shouldWrite = function shouldWrite(_ref, no, yes) {
  var debug = _ref.debug,
      filepath = _ref.filepath,
      overwrite = _ref.overwrite;

  _fs2.default.access(filepath, function (err) {
    if (!err && !overwrite) {
      debug('Exists, skipping ' + filepath);
      no();
    } else if (!err && overwrite) {
      debug('Exists, overwriting ' + filepath);
      yes();
    } else {
      debug('Does not exist, writing ' + filepath);
      yes();
    }
  });
};

var saveJson = exports.saveJson = function saveJson(_ref2) {
  var ig = _ref2.ig,
      jsonDir = _ref2.jsonDir,
      refresh = _ref2.refresh,
      full = _ref2.full;
  return function (json, saveDone) {
    var id = json.id;
    var filepath = jsonDir(id + '.json');

    var writeIfNeeded = (0, _partial2.default)(shouldWrite, { debug: debugJson, filepath: filepath, overwrite: refresh }, saveDone);
    var writeFile = function writeFile(data) {
      return _fs2.default.writeFile(filepath, JSON.stringify(data), { encoding: 'utf8' }, saveDone);
    };

    var fetchForPost = function fetchForPost(fetch) {
      return function (cb) {
        return ig[fetch](id, function (err, res, remaining) {
          debugApi('API calls left ' + remaining);
          if (err) {
            debugApi(fetch + ' API error ' + err);
            return cb(err);
          }
          cb(null, res);
        });
      };
    };

    writeIfNeeded(function () {
      if (full) {
        // Full means we fetch likes and comments separately and add those
        // to the json payload that gets saved
        (0, _async.parallel)({
          likes: fetchForPost('likes'),
          comments: fetchForPost('comments')
        }, function (err, _ref3) {
          var likes = _ref3.likes,
              comments = _ref3.comments;

          if (err) return saveDone(err);
          json.likes.data = likes;
          json.comments.data = comments;
          debugJson(id + ' likes count:' + json.likes.count + ' data:' + likes.length);
          debugJson(id + ' comments count:' + json.comments.count + ' data:' + comments.length);
          writeFile(json);
        });
      } else {
        writeFile(json);
      }
    });
  };
};

var saveMedia = exports.saveMedia = function saveMedia(_ref4) {
  var mediaDir = _ref4.mediaDir;
  return function (url, saveDone) {
    // Make sure callback is always called once since we need both error and close events
    // https://github.com/caolan/async/issues/614#issuecomment-55045730
    var saveDoneOnce = (0, _once2.default)(saveDone);

    // The Instagram media files get saved to a location on disk that matches the
    // urls domain+path, so we need to make that directory and then save the file

    var _urlToPath = (0, _urlToPath3.default)({ mediaDir: mediaDir, url: url }),
        filepath = _urlToPath.filepath,
        dirname = _urlToPath.dirname;

    // An Instagram media at a url should never change so we shouldn't ever
    // need to download it more than once


    var writeIfNeeded = (0, _partial2.default)(shouldWrite, { debug: debugMedia, filepath: filepath, overwrite: false }, saveDoneOnce);

    writeIfNeeded(function () {
      (0, _mkdirp2.default)(dirname, function (err) {
        if (err) {
          debugMedia('Error creating dir ' + dirname + ': ' + err);
          return saveDoneOnce(err);
        }
        (0, _request2.default)(url).on('error', function (err) {
          debugMedia('Error fetching media ' + url + ': ' + err);
          saveDoneOnce(err);
        }).pipe(_fs2.default.createWriteStream(filepath)).on('close', saveDoneOnce);
      });
    });
  };
};

var fetchAndSave = exports.fetchAndSave = function fetchAndSave(_ref5, cb) {
  var jsonQueue = _ref5.jsonQueue,
      mediaQueue = _ref5.mediaQueue;

  var COUNT = 0;

  // The callback passed to the function will be executed once
  // both json and media queues have been drained
  var onDrain = function onDrain() {
    if (mediaQueue.running() === 0 && jsonQueue.running() === 0) {
      cb();
    }
  };

  jsonQueue.drain = function () {
    debugJson('queue drain');
    onDrain();
  };

  mediaQueue.drain = function () {
    debugMedia('queue drain');
    onDrain();
  };

  var fetchMedia = function fetchMedia(err, medias, pagination, remaining) {
    debugApi('API calls left ' + remaining);

    if (err) {
      debugApi('API error ' + err);
      debugApi(err);
      debugApi(err.body);
      if (err.error_type === 'APINotAllowedError' || err.error_type === 'APINotFoundError') {
        debugApi('Its possible the user\'s account you are trying to download is private');
        debugApi('If you are running your Instagram client in Sandbox mode, make sure the user is added as a Sandbox user');
      }
    } else if (medias && medias.length) {
      COUNT += medias.length;
      debugApi('Fetched media ' + medias.length);
      debugApi('Fetched total ' + COUNT);
      medias.forEach(function (media) {
        // Special stuff for https://github.com/lukekarrys/instagram-download/issues/3
        if (media.images) {
          var _media$images = media.images,
              thumbnail = _media$images.thumbnail,
              standardResolution = _media$images.standard_resolution;

          if (thumbnail) {
            // high res uncropped
            // remove s150x150 and c0.134.1080.1080 from
            // t51.2885-15/s150x150/e35/c0.134.1080.1080/12725175_958336534244864_1369827234_n.jpg
            var highRes = stripUrlParts(thumbnail.url, /^s\d+x\d+$/, /^c\d+\.\d+\.\d+\.\d+$/);
            if (highRes) media.images.high_resolution = { url: highRes };
          }
          // high res cropped
          // remove s640x640 from
          // t51.2885-15/s640x640/sh0.08/e35/12502019_964211777003492_661892888_n.jpg
          if (standardResolution) {
            var highResCropped = stripUrlParts(standardResolution.url, /^s\d+x\d+$/);
            if (highResCropped) media.images.high_resolution_cropped = { url: highResCropped };
          }
        }
        jsonQueue.push(media);
        (0, _each2.default)(media.images, function (img) {
          return mediaQueue.push(img.url);
        });
        (0, _each2.default)(media.videos, function (video) {
          return mediaQueue.push(video.url);
        });
      });
    } else if (medias.length === 0 && COUNT === 0 && !pagination.next) {
      debugApi('No media');
      cb();
    }

    if (pagination) {
      debugApi('Has next page ' + !!pagination.next);
      pagination.next && pagination.next(fetchMedia);
    }
  };

  return fetchMedia;
};