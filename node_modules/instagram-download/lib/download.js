'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _instagramNode = require('instagram-node');

var _async = require('async');

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _partial = require('lodash/partial');

var _partial2 = _interopRequireDefault(_partial);

var _requiredOptions2 = require('./util/requiredOptions');

var _requiredOptions3 = _interopRequireDefault(_requiredOptions2);

var _saveFiles = require('./util/saveFiles');

var _constants = require('./util/constants');

var _read = require('./read');

var _read2 = _interopRequireDefault(_read);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('./util/debug')('download');

exports.default = function (options, cb) {
  var _requiredOptions = (0, _requiredOptions3.default)(options, ['dir', 'token', 'user']),
      dir = _requiredOptions.dir,
      token = _requiredOptions.token,
      user = _requiredOptions.user,
      refresh = _requiredOptions.refresh,
      full = _requiredOptions.full;

  // Directories for saving files


  var userDir = (0, _partial2.default)(_path2.default.join, dir, user);
  var jsonDir = (0, _partial2.default)(userDir, _constants.JSON_DIRNAME);
  var mediaDir = (0, _partial2.default)(userDir, _constants.MEDIA_DIRNAME);
  debug('User dir ' + userDir());
  debug('Json dir ' + jsonDir());
  debug('Media dir ' + mediaDir());

  // Configure our instagram API instance
  var ig = (0, _instagramNode.instagram)();
  ig.use({ access_token: token });

  // Make sure all our directories are created and
  // then start the instagram fetching
  (0, _async.series)({
    json: function json(cb) {
      return (0, _mkdirp2.default)(jsonDir(), cb);
    },
    media: function media(cb) {
      return (0, _mkdirp2.default)(mediaDir(), cb);
    },
    data: function data(cb) {
      return (0, _read2.default)({ dir: dir, user: user }, cb);
    }
  }, function (err, results) {
    if (err) return cb(err);

    var igOptions = { count: _constants.MAX_COUNT };

    var _results$data = _slicedToArray(results.data, 1),
        first = _results$data[0];

    // This is our most recent instagram photo so we use it as a min_id
    // to only fetch photos newer than this


    if (first && first.created_time && !refresh) {
      igOptions.min_timestamp = Number(first.created_time) + 1;
      debug('Fetching since ' + first.id + ' ' + new Date(Number(first.created_time) * 1000).toJSON());
    }

    var queueOptions = { ig: ig, jsonDir: jsonDir, mediaDir: mediaDir, refresh: refresh, full: full };
    var jsonQueue = (0, _async.queue)((0, _saveFiles.saveJson)(queueOptions), _constants.QUEUE_CONCURRENCY);
    var mediaQueue = (0, _async.queue)((0, _saveFiles.saveMedia)(queueOptions), _constants.QUEUE_CONCURRENCY);

    // Fetch the first page of most recent media
    // The fetchAndSave callback will take care of iterating over each page
    ig.user_media_recent(user, igOptions, (0, _saveFiles.fetchAndSave)({ jsonQueue: jsonQueue, mediaQueue: mediaQueue }, cb));
  });
};

module.exports = exports['default'];